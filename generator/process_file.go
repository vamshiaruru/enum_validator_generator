package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/mod/modfile"
)

const validationTemplate = `
// Code generated by enum-validator-generator. DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"
	"slices"

	"{{.TecValidatorImport}}"
)

{{- range .Enums}}

func ({{.ReceiverName}} {{.TypeName}}) Validate() []tecvalidator.ValidationError {
	allowedValues := []string{
		{{- range .Values}}
		string({{.}}),
		{{- end}}
	}
	if !slices.Contains(allowedValues, string({{.ReceiverName}})) {
		return []tecvalidator.ValidationError{
			{
				Field: "",
				Error: fmt.Sprintf("Invalid {{.TypeName}}: %s", {{.ReceiverName}}),
				AdditionalData: map[string]any{
					"allowedValues": allowedValues,
				},
			},
		}
	}
	return nil
}
{{- end}}
`

type enumInfo struct {
	TypeName     string
	ReceiverName string
	Values       []string
}

type fileInfo struct {
	PackageName        string
	Enums              []enumInfo
	TecValidatorImport string
}

func Run() error {
	modName, err := getModuleName()
	if err != nil {
		return fmt.Errorf("error getting module name: %v", err)
	}

	err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			if err := processFile(path, modName); err != nil {
				log.Printf("Error processing file %s: %v", path, err)
			}
		}
		return nil
	})

	if err != nil {
		return fmt.Errorf("error walking through directory: %v", err)
	}

	return nil
}

func getModuleName() (string, error) {
	goModPath := filepath.Join("go.mod")
	content, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("error reading go.mod file: %v", err)
	}

	modName := modfile.ModulePath(content)
	if modName == "" {
		return "", fmt.Errorf("unable to determine module name from go.mod")
	}

	return modName, nil
}

func processFile(fileName, modName string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("error parsing file %s: %v", fileName, err)
	}

	fileInfo := fileInfo{
		PackageName:        node.Name.Name,
		TecValidatorImport: fmt.Sprintf("%s/internal/tecvalidator", modName),
	}

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE && x.Doc != nil {
				for _, comment := range x.Doc.List {
					if strings.Contains(comment.Text, "go:generate validator") {
						for _, spec := range x.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if _, ok := typeSpec.Type.(*ast.Ident); ok {
									enum := enumInfo{
										TypeName:     typeSpec.Name.Name,
										ReceiverName: strings.ToLower(string(typeSpec.Name.Name[0])),
									}
									fileInfo.Enums = append(fileInfo.Enums, enum)
								}
							}
						}
					}
				}
			} else if x.Tok == token.CONST {
				for _, spec := range x.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						if len(valueSpec.Names) > 0 && len(fileInfo.Enums) > 0 {
							fileInfo.Enums[len(fileInfo.Enums)-1].Values = append(fileInfo.Enums[len(fileInfo.Enums)-1].Values, valueSpec.Names[0].Name)
						}
					}
				}
			}
		}
		return true
	})

	if len(fileInfo.Enums) == 0 {
		return nil
	}

	tmpl, err := template.New("validation").Parse(validationTemplate)
	if err != nil {
		return fmt.Errorf("error parsing template for %s: %v", fileName, err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, fileInfo)
	if err != nil {
		return fmt.Errorf("error executing template for %s: %v", fileName, err)
	}

	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting generated code for %s: %v", fileName, err)
	}

	outputFileName := strings.TrimSuffix(fileName, ".go") + "_enum_validations.go"
	err = os.WriteFile(outputFileName, formattedCode, 0644)
	if err != nil {
		return fmt.Errorf("error writing output file for %s: %v", fileName, err)
	}

	fmt.Printf("Generated validation functions for %s in %s\n", fileName, outputFileName)
	return nil
}
